"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[5715],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(a),c=r,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||i;return a?n.createElement(h,l(l({ref:t},d),{},{components:a})):n.createElement(h,l({ref:t},d))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},9338:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={},l="Guest Optimization Guide",o={unversionedId:"zkvm/developer-guide/optimization",id:"zkvm/developer-guide/optimization",title:"Guest Optimization Guide",description:"RISC Zero\u2019s zkVM is designed and built to act like a physical CPU.",source:"@site/docs/zkvm/developer-guide/optimization.md",sourceDirName:"zkvm/developer-guide",slug:"/zkvm/developer-guide/optimization",permalink:"/website-preview/risc0/risc0/pr/1080/next/zkvm/developer-guide/optimization",draft:!1,editUrl:"https://github.com/risc0/risc0/edit/main/website/docs/zkvm/developer-guide/optimization.md",tags:[],version:"current",frontMatter:{},sidebar:"GettingStartedSidebar",previous:{title:"Receipts 101",permalink:"/website-preview/risc0/risc0/pr/1080/next/zkvm/developer-guide/receipts"},next:{title:"Guest Profiling Guide",permalink:"/website-preview/risc0/risc0/pr/1080/next/zkvm/developer-guide/profiling"}},s={},p=[{value:"Background",id:"background",level:2},{value:"What is the zkVM, really?",id:"what-is-the-zkvm-really",level:3},{value:"What is a \u201ccycle\u201d?",id:"what-is-a-cycle",level:3},{value:"General techniques and advice",id:"general-techniques-and-advice",level:2},{value:"Don\u2019t assume, measure.",id:"dont-assume-measure",level:3},{value:"Measuring by printing to console",id:"measuring-by-printing-to-console",level:3},{value:"Profiling",id:"profiling",level:3},{value:"Key Differences",id:"key-differences",level:2},{value:"Most RISC-V operations take exactly one cycle",id:"most-risc-v-operations-take-exactly-one-cycle",level:3},{value:"Memory access costs one cycle, except when it doesn\u2019t",id:"memory-access-costs-one-cycle-except-when-it-doesnt",level:3},{value:"Paging",id:"paging",level:4},{value:"The zkVM does not have native floating point operations",id:"the-zkvm-does-not-have-native-floating-point-operations",level:3},{value:"Unaligned data access is significantly more expensive",id:"unaligned-data-access-is-significantly-more-expensive",level:3},{value:"When reading data as raw bytes, use <code>env::read_slice</code>",id:"when-reading-data-as-raw-bytes-use-envread_slice",level:3},{value:"When you only need part of the input data, try Merklizing it",id:"when-you-only-need-part-of-the-input-data-try-merklizing-it",level:3},{value:"Cryptography in the guest can utilize accelerator circuits",id:"cryptography-in-the-guest-can-utilize-accelerator-circuits",level:3},{value:"Memory access is synchronous",id:"memory-access-is-synchronous",level:3},{value:"All execution is single-threaded",id:"all-execution-is-single-threaded",level:3},{value:"The zkVM has no pipelining or other instruction-level parallelism.",id:"the-zkvm-has-no-pipelining-or-other-instruction-level-parallelism",level:3},{value:"Prover Acceleration",id:"prover-acceleration",level:2},{value:"TL;DR and quick wins",id:"tldr-and-quick-wins",level:2},{value:"Appendix",id:"appendix",level:2},{value:"RV32IM Operations with Cycle Counts",id:"rv32im-operations-with-cycle-counts",level:3},{value:"RISC Zero ECALL Operations",id:"risc-zero-ecall-operations",level:3}],d={toc:p},m="wrapper";function u(e){let{components:t,...i}=e;return(0,r.kt)(m,(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"guest-optimization-guide"},"Guest Optimization Guide"),(0,r.kt)("p",null,"RISC Zero\u2019s zkVM is designed and built to act like a physical CPU.\nWe did this so you could use general purpose languages (e.g. Rust) and general purpose tools (e.g. Cargo, LLVM). ",(0,r.kt)("strong",{parentName:"p"},"Generally, you can apply general purpose optimization techniques too!")),(0,r.kt)("p",null,"In this guide, we\u2019ll cover optimization of ",(0,r.kt)("a",{parentName:"p",href:"./guest-code-101"},"zkVM guest programs"),".\nWe\u2019ll discuss when you can apply common techniques from other contexts, and when you need a new approach."),(0,r.kt)("h2",{id:"background"},"Background"),(0,r.kt)("h3",{id:"what-is-the-zkvm-really"},"What is the zkVM, really?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The zkVM is essentially a CPU.")),(0,r.kt)("p",null,"In particular, it is an implementation of the ",(0,r.kt)("a",{parentName:"p",href:"/reference-docs/about-risc-v"},"RISC-V architecture")," (specifically riscv32im), similar to how your laptop\u2019s CPU may be an implementation of an ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/X86"},"x86")," or ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/ARM_architecture_family"},"ARM")," architecture.\nThis biggest difference is that the zkVM is implemented with ",(0,r.kt)("a",{parentName:"p",href:"/reference-docs/about-arithmetic-circuits"},"arithmetic circuits"),", in software, instead of circuitry made from silicon and copper."),(0,r.kt)("h3",{id:"what-is-a-cycle"},"What is a \u201ccycle\u201d?"),(0,r.kt)("p",null,"Both in the zkVM and on physical CPUs, the cost of an operation is measured in \u201cclock cycles\u201d."),(0,r.kt)("p",null,"Intuitively, a \"clock cycle\" is the smallest unit of time in a CPU's operation, representing one tick of the CPU's internal clock and the time it takes to execute a basic CPU operation (e.g. adding two integers).\nWe\u2019ll refer to this as a \u201ccycle\u201d. ",(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Proving times for the zkVM are directly related to the number of cycles in an execution.")),(0,r.kt)("h2",{id:"general-techniques-and-advice"},"General techniques and advice"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Start by applying general techniques and best practices for optimizing your code.")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://nnethercote.github.io/perf-book/"},"The Rust Performance Book")," is great resource.\nIt\u2019s not very long, it covers a range of topics important to performance, and gives applicable advice for optimization.\nIf you are new to optimization, or new to Rust, we recommend you read this guide."),(0,r.kt)("h3",{id:"dont-assume-measure"},"Don\u2019t assume, measure."),(0,r.kt)("p",null,"Performance is complex, in the zkVM as on a physical CPU.\nDon\u2019t assume you know what the bottlenecks are. Measure and experiment."),(0,r.kt)("p",null,"If you make a function 100x faster (or \u221ex faster) but it only takes 1% of your execution time, you\u2019ll see less than 1% improvement in performance.\nThis is generally referred to as ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Amdahl%27s_law"},"Amdahl\u2019s Law"),", and practically it means you shouldn't waste your time optimizing something that's not the taking a significant portion of execution time."),(0,r.kt)("h3",{id:"measuring-by-printing-to-console"},"Measuring by printing to console"),(0,r.kt)("p",null,"Starting simple, measure by adding an ",(0,r.kt)("inlineCode",{parentName:"p"},"eprintln!")," line to your guest code to measure how long an operation takes, and how many times it is called."),(0,r.kt)("p",null,"Using ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/risc0-zkvm/0.19/risc0_zkvm/guest/env/fn.get_cycle_count.html"},(0,r.kt)("inlineCode",{parentName:"a"},"env::get_cycle_count()"))," will tell you the current number of execution cycles that have occurred in your program."),(0,r.kt)("p",null,"As an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="methods/guest/src/main.rs"',title:'"methods/guest/src/main.rs"'},'fn my_operation_to_measure() {\n  let start = env::get_cycle_count();\n\n  // potentially expensive or frequently called code\n  // ...\n\n  let end = env::get_cycle_count();\n  eprintln!("my_operation_to_measure: {}", end - start);\n}\n')),(0,r.kt)("p",null,"When you run your guest, you\u2019ll see a printout of the cycle count each time that function is called.\nYou can then analyze this data easily with a tool like ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/nnethercote/counts/"},(0,r.kt)("inlineCode",{parentName:"a"},"counts")),"."),(0,r.kt)("h3",{id:"profiling"},"Profiling"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Profiling is one of the most important tools for understanding and optimizing your code.")),(0,r.kt)("p",null,"Profiling tools, like ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/google/pprof"},"pprof")," and ",(0,r.kt)("a",{parentName:"p",href:"https://perf.wiki.kernel.org/index.php/Main_Page"},"perf"),", allow collecting performance information over the entire execution of your program, and help create visualizations for the performance of your program.\nRISC Zero has experimental support for generating pprof files for cycle counts."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://nikhilism.com/post/2018/sampling-profiler-internals-introduction/"},"Sampling CPU profilers"),', as implemented by pprof and perf, provide a view of where your program is spending its time.\nIt does so by recording the current call stack at a sampling interval.\nRISC Zero provides a "sampling" ',(0,r.kt)("sup",{parentName:"p",id:"fnref-2"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," CPU profiler for guest execution."),(0,r.kt)("p",null,"One very useful visualization of this data is as a ",(0,r.kt)("a",{parentName:"p",href:"https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html"},"flamegraph"),", such as the one below for the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/risc0/risc0/tree/v0.19.0/examples/ecdsa"},"ECDSA verification example"),"."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"ECDSA verification flamegraph",src:a(2613).Z,width:"1812",height:"456"})),(0,r.kt)("p",null,"Generate this profile and flamegraph by ",(0,r.kt)("a",{parentName:"p",href:"https://go.dev/doc/install"},"installing Go")," and running the following commands:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# In your clone of github.com/risc0/risc0\ncd examples/ecdsa\nRISC0_PPROF_OUT=ecdsa_verify.pprof cargo run --release --bin profile\ngo tool pprof -http 127.0.0.1:8000 ecdsa_verify.pprof\n")),(0,r.kt)("p",null,"Open ",(0,r.kt)("a",{parentName:"p",href:"http://127.0.0.1:8000/ui/flamegraph"},"http://127.0.0.1:8000/ui/flamegraph")," in your web browser to see the flamegraph."),(0,r.kt)("p",null,"Although it\u2019s bundled with Go, the ",(0,r.kt)("inlineCode",{parentName:"p"},"pprof")," tool can be used with profiles from programs not written in Golang.\n",(0,r.kt)("inlineCode",{parentName:"p"},"pprof")," has extensive functionality, and the documentation linked below contains information about the different views provided, comparing profiles, and much more."),(0,r.kt)("p",null,"Documentation for ",(0,r.kt)("inlineCode",{parentName:"p"},"pprof"),": ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/google/pprof/blob/main/doc/README.md"},"github.com/google/pprof")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"More information about profiling can be found in the ",(0,r.kt)("a",{parentName:"strong",href:"./profiling"},"Guest Profiling Guide"))),(0,r.kt)("h2",{id:"key-differences"},"Key Differences"),(0,r.kt)("p",null,"Using general purpose advice and tools for optimization will work 80% of the time.\nBut there are some key differences between how physical CPUs and the zkVM operate that can be important to understand when trying to get the best possible guest performance."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This section explains some of the most important differences between a physical CPU and the zkVM, as they relate to guest performance.")),(0,r.kt)("h3",{id:"most-risc-v-operations-take-exactly-one-cycle"},"Most ",(0,r.kt)("a",{parentName:"h3",href:"https://mark.theis.site/riscv/"},"RISC-V operations")," take exactly one cycle"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Not all operations cost the same amount."),"\nAn ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," instruction takes fewer cycles than a ",(0,r.kt)("inlineCode",{parentName:"p"},"div"),". This is true for both the zkVM and physical CPUs."),(0,r.kt)("p",null,"However, the relative difference between instructions is much smaller in the zkVM.\nIn the zkVM, a ",(0,r.kt)("inlineCode",{parentName:"p"},"div")," takes twice as long as an ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),".\nOn a physical CPU, a ",(0,r.kt)("inlineCode",{parentName:"p"},"div")," takes ",(0,r.kt)("a",{parentName:"p",href:"http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/"},"15-40 times")," as long compared to an ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),".\nPractically, this means if you have a choice between implementing ",(0,r.kt)("a",{parentName:"p",href:"https://briansmith.org/ecc-inversion-addition-chains-01"},"an algorithm")," with 10 ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," ops, or a single ",(0,r.kt)("inlineCode",{parentName:"p"},"div"),". On a physical CPU, choose the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," ops. In the zkVM choose the ",(0,r.kt)("inlineCode",{parentName:"p"},"div"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Addition, comparison, jump, shift left, load and store all take one cycle."),(0,r.kt)("li",{parentName:"ul"},"Bitwise operations (AND, OR, XOR), division, remainder, and shift right take two cycles.")),(0,r.kt)("p",null,"Note that this means that shift left is no faster than multiplying by a power of two, and shift right is no faster than division.\nA number of other small optimizations like this, routinely applied by developers and compilers, have no effect in the zkVM."),(0,r.kt)("p",null,"See the ",(0,r.kt)("a",{parentName:"p",href:"#rv32im-operations-with-cycle-counts"},"table in the appendix")," for more information about cycle counts per operation."),(0,r.kt)("h3",{id:"memory-access-costs-one-cycle-except-when-it-doesnt"},"Memory access costs one cycle, except when it doesn\u2019t"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://mark.theis.site/riscv/"},"RISC-V operations")," require data to be loaded from memory to ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Processor_register"},"registers")," before it can acted on (e.g. used as input to an ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),").\nIt must also be written back to memory to store the result. Memory loads and stores (i.e. reads and writes) usually take one cycle."),(0,r.kt)("p",null,"Memory access, both load and store takes exactly one cycle, expect in the case of page-in and page-out operations (",(0,r.kt)("a",{parentName:"p",href:"#paging"},"discussed below"),")."),(0,r.kt)("p",null,"Note that relative to a physical CPU, this is extremely fast (in terms of cycles).\nOn a physical CPU even a value in ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cache_hierarchy"},"L1 cache")," takes ",(0,r.kt)("a",{parentName:"p",href:"http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/"},"3-4 cycles")," to access.\nL3 cache takes ",(0,r.kt)("a",{parentName:"p",href:"http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/"},"30-70 cycles")," and main memory ",(0,r.kt)("a",{parentName:"p",href:"http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/"},"100-150"),".\nOne of the most common bottlenecks in applications is the round-trip time it takes to access a data in memory."),(0,r.kt)("h4",{id:"paging"},"Paging"),(0,r.kt)("p",null,"Every execution of the zkVM starts from an initial memory state.\nThis memory state (a.k.a. image) is referenced by an ",(0,r.kt)("a",{parentName:"p",href:"https://dev.risczero.com/terminology#image-id"},"image ID"),", which contains a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Merkle_tree"},"Merkle root")," committing to all data in memory.\nFor efficiency, data in memory is split into 1 kB pages."),(0,r.kt)("p",null,"Pages in the zkVM are analogous a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Page_(computer_memory)"},"page in an operating system"),", and in particular this term was chosen in reference to ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Memory_paging"},"memory paging"),", or swapping, systems.\nExecution of a program is split into ",(0,r.kt)("a",{parentName:"p",href:"https://www.risczero.com/news/continuations"},"continuation segments"),".\nBetween segments, the zkVM essentially ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Hibernation_(computing)"},"hibernates"),", saving all working memory to the host; as a CPU would use a hard drive."),(0,r.kt)("p",null,"The first time a page is accessed in a segment, it needs to be ",(0,r.kt)("strong",{parentName:"p"},"paged-in"),", loading it from the host.\nConfirming the page is correct, the guest verifies a Merkle inclusion proof for the page against the image ID.\nThese hashing operations required take a number of cycles."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A page-in operation takes between 1094 and 5130 cycles; 1130 cycles on average."),(0,r.kt)("sup",{parentName:"p",id:"fnref-3"},(0,r.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3"))),(0,r.kt)("p",null,"The very first page-in takes longer, 5130 cycles, because it needs to traverse up the page table (i.e. Merkle tree) all the way to the root, which is equal to the image ID.\nOnce a path is verified, it doesn\u2019t need to be hashed again, so most page-in operations only need to hash the leaf (i.e. data) page.\nIf a program were to iterate over memory in sequence, it would cost on average 1130 cycles per page, or 1.35 cycles per byte."),(0,r.kt)("p",null,"In order to support continuation after the segment ends (i.e. the zkVM \u201chibernates\u201d), it needs to ",(0,r.kt)("strong",{parentName:"p"},"page-out")," pages that were modified.\nPaging-out takes the same number of operations as paging-in, so for the first time any given page is written to in a segment, there is an page-out cost of 1094 to 5130 cycles."),(0,r.kt)("p",null,"If, after profiling your application, you learn page-in and page-out operations are a significant overhead, you can optimize your application by reducing it\u2019s memory usage and locality.\nThis will be somewhat similar to optimizing for data locality and L1/2 cache usage.\nUsing fewer pages, using the same page repeatedly instead of a random access pattern, and condensing the range of addresses accessed can all help reduce paging overhead.\nIt\u2019s best to experiment."),(0,r.kt)("h3",{id:"the-zkvm-does-not-have-native-floating-point-operations"},"The zkVM does not have native floating point operations"),(0,r.kt)("p",null,"The RISC Zero zkVM does not implement the RISC-V floating point instructions.\nAs a result, all floating point operations are emulated in software.\nIn contrast to integer operations that take 1-2 cycles, floating point operations can take 60-140 cycles for basic operations such as add, subtract, multiply, and divide."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"When possible, use integers instead of floating point numbers.")),(0,r.kt)("h3",{id:"unaligned-data-access-is-significantly-more-expensive"},"Unaligned data access is significantly more expensive"),(0,r.kt)("p",null,"CPUs define a standard size of data for operation; and this is referred to as a word.\nIn RISC-V 32-bit ISA, the size of a word is 32 bits (4 bytes).\nMemory is always read and stored as words."),(0,r.kt)("p",null,"When the read or store address is not a multiple of 4 bytes, the operation is much more expensive.\nIn a simple benchmark, reading an unaligned ",(0,r.kt)("inlineCode",{parentName:"p"},"u32")," value costs 12 cycles, versus 1 cycle for an aligned read."),(0,r.kt)("p",null,"All allocations will be aligned by default, and the compiler wants to help you, so this should usually not be an issue."),(0,r.kt)("p",null,"If you are defining structs that containing small primitive typed fields (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"u8"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"i16"),") and access this data very frequently, you might consider paying extra care to the ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers"},"alignment of those fields"),".\nAdditionally, if you are slicing into byte arrays, try to do so at word-aligned indices."),(0,r.kt)("h3",{id:"when-reading-data-as-raw-bytes-use-envread_slice"},"When reading data as raw bytes, use ",(0,r.kt)("inlineCode",{parentName:"h3"},"env::read_slice")),(0,r.kt)("p",null,"When reading input into the guest, ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/risc0-zkvm/latest/risc0_zkvm/guest/env/fn.read.html"},(0,r.kt)("inlineCode",{parentName:"a"},"env::read"))," is the main API to use.\nIt automatically deserializes the input bytes into structs, like in this ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/risc0/risc0/blob/v0.19.0/examples/password-checker/methods/guest/src/main.rs#L24"},"snippet from the password checker example"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let request: PasswordRequest = env::read();\n")),(0,r.kt)("p",null,"In the host code, ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorEnvBuilder::write")," function is used to serialize and write to input struct so that the guest can read it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let request: PasswordRequest = // ...\nlet env = ExecutorEnv::builder()\n        .write(&request).unwrap()\n        .build()\n        .unwrap();\n")),(0,r.kt)("p",null,"In most cases, these APIs are what you should use to send data to the guest."),(0,r.kt)("p",null,"However, when you need to read and work with data as raw bytes (or words), it is more efficient to use ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/risc0-zkvm/0.19/risc0_zkvm/guest/env/fn.read_slice.html"},(0,r.kt)("inlineCode",{parentName:"a"},"env::read_slice"))," or ",(0,r.kt)("inlineCode",{parentName:"p"},"env::stdin().read_to_end"),".\nBoth methods do no (de)serialization and so do not need to copy or reinterpret the input data.\nExamples of when this may be useful are if you are reading in image data as bytes, or reading data that is binary encoded from the source like with ",(0,r.kt)("a",{parentName:"p",href:"https://cbor.io/"},"CBOR"),"."),(0,r.kt)("p",null,"Here is a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/risc0/risc0/blob/v0.19.0/bonsai/examples/governance/methods/guest/src/bin/finalize_votes.rs#L88-L90"},"snippet from the Bonsai Governance example")," showing how to read bytes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let mut input_bytes = Vec::<u8>::new();\nenv::stdin().read_to_end(&mut input_bytes).unwrap();\n")),(0,r.kt)("p",null,"On the host side, ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorEnvBuilder::write_slice")," is used to pass in the bytes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let input_bytes: Vec<u8> = // ...\nlet env = ExecutorEnv::builder()\n        .write_slice(&input_bytes)\n        .build()\n        .unwrap();\n")),(0,r.kt)("h3",{id:"when-you-only-need-part-of-the-input-data-try-merklizing-it"},"When you only need part of the input data, try Merklizing it"),(0,r.kt)("p",null,"Some programs only need part of the whole available data.\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/risc0/risc0/tree/v0.19.0/examples/waldo"},"Where\u2019s Waldo")," is an example of this.\nThe full input is an image, but only the part with Waldo in it is needed.\nLoading and hashing the whole image would be quite expensive, so instead the initial input for the guest is just the Merkle root and each chunk is loaded dynamically.\nThe guest verifies that the chunk is indeed part of the image by verifying the Merkle inclusion proof."),(0,r.kt)("p",null,"If you are writing a guest with a large input, and only part of it is needed for the computation, consider splitting it into some notion of a chunks and building it as a Merkle tree.\nYou can use the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/risc0/risc0/blob/main/examples/waldo/core/src/merkle.rs"},"code for Where\u2019s Waldo")," as a starting point."),(0,r.kt)("h3",{id:"cryptography-in-the-guest-can-utilize-accelerator-circuits"},"Cryptography in the guest can utilize accelerator circuits"),(0,r.kt)("p",null,"RISC Zero\u2019s riscv32im implementation includes a number of special purpose operations, including two \u201caccelerators\u201d for cryptographic functions: SHA-256 and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/risc0/risc0/pull/466"},"256-bit modular multiplication"),".\nBy implementing these operations directly in the \u201chardware\u201d of the zkVM, programs that use these accelerators execute faster and can be proven with significantly less resources ",(0,r.kt)("sup",{parentName:"p",id:"fnref-4"},(0,r.kt)("a",{parentName:"sup",href:"#fn-4",className:"footnote-ref"},"4")),"."),(0,r.kt)("p",null,"For more information about cryptography acceleration, ",(0,r.kt)("a",{parentName:"p",href:"./acceleration"},"cryptography acceleration"),"."),(0,r.kt)("p",null,"Using the accelerator, a SHA-256 compress operation typically takes 68 cycles per 64-byte block and 6 cycles to initialize.\nA 256-bit modular multiply takes 10 cycles.\nThis includes basic memory operation cycles, but does not include page-in or page-out operations that are triggered."),(0,r.kt)("h3",{id:"memory-access-is-synchronous"},"Memory access is synchronous"),(0,r.kt)("p",null,"On a physical CPU, memory access is asynchronous to register operations; meaning arithmetic or logic operations on registers can run while the CPU is waiting for the result from memory.\nBecause the memory fetch latency is quite large (100-150x the time to ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," two registers), this gives rise to techniques such as prefetching and speculative execution, implemented both at the processor and application levels."),(0,r.kt)("p",null,"In the zkVM, all memory operations are synchronous, regardless of if the data is currently paged-in.\n",(0,r.kt)("strong",{parentName:"p"},"Memory prefetching does not help (but can hurt) zkVM guest performance.")),(0,r.kt)("h3",{id:"all-execution-is-single-threaded"},"All execution is single-threaded"),(0,r.kt)("p",null,"The zkVM has one core and one thread of execution.\nAs a result, there is no need or use for multi-threading.\n",(0,r.kt)("strong",{parentName:"p"},"Using ",(0,r.kt)("inlineCode",{parentName:"strong"},"async")," routines, locking, or atomic operations in the guest can only slow the program down.")),(0,r.kt)("h3",{id:"the-zkvm-has-no-pipelining-or-other-instruction-level-parallelism"},"The zkVM has no pipelining or other instruction-level parallelism."),(0,r.kt)("p",null,"Modern processors have execution pipelines and ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Superscalar_processor"},"superscalar architectures")," designed to ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Instruction-level_parallelism"},"execute instructions in parallel"),".\nInstruction throughput is much higher when the pipeline is kept full and independent execution units are utilized.\nCPUs implement out-of-order and speculative execution, among other techniques to achieve this."),(0,r.kt)("p",null,"By comparison, RISC Zero\u2019s riscv32im implementation is very simple.\nInstructions will be read from the guest program and executed in the order chosen by the compiler."),(0,r.kt)("p",null,"Developers and compilers often use techniques such as pre-fetching, avoiding branches, or reordering instructions to maximize instruction-level parallelism.\n",(0,r.kt)("strong",{parentName:"p"},"These techniques have essentially no effect in the zkVM.")),(0,r.kt)("h2",{id:"prover-acceleration"},"Prover Acceleration"),(0,r.kt)("p",null,"You are probably interested in guest optimization in order to have faster proving times, to reduce compute costs, or both.\nRISC Zero can leverage hardware accelerators, the ones made of real silicon this time, to accomplish both of these objectives. ",(0,r.kt)("sup",{parentName:"p",id:"fnref-5"},(0,r.kt)("a",{parentName:"sup",href:"#fn-5",className:"footnote-ref"},"5"))),(0,r.kt)("p",null,"With an NVIDIA graphics card, proving can be accelerated through the ",(0,r.kt)("a",{parentName:"p",href:"https://developer.nvidia.com/cuda-toolkit"},"CUDA")," implementation.\nWhen running a zkVM application, a compatible version of the CUDA runtime needs to be installed.\nWhen building the zkVM from source, a compatible version of the CUDA toolkit needs to be installed on the build machine, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"cuda")," feature enabled."),(0,r.kt)("h2",{id:"tldr-and-quick-wins"},"TL;DR and quick wins"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./profiling"},"Profile your applications")," to find where cycles are being spent."),(0,r.kt)("li",{parentName:"ul"},"Try different ",(0,r.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/cargo/reference/profiles.html"},"compiler settings"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Setting ",(0,r.kt)("inlineCode",{parentName:"li"},'lto = "thin"')," is sometimes faster than ",(0,r.kt)("inlineCode",{parentName:"li"},'lto = "fat"')," or ",(0,r.kt)("inlineCode",{parentName:"li"},"lto = true"),"."),(0,r.kt)("li",{parentName:"ul"},"Sometimes ",(0,r.kt)("inlineCode",{parentName:"li"},"opt-level = 2")," is faster than ",(0,r.kt)("inlineCode",{parentName:"li"},"3"),". Try ",(0,r.kt)("inlineCode",{parentName:"li"},"s")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"z")," too."),(0,r.kt)("li",{parentName:"ul"},"Try setting ",(0,r.kt)("inlineCode",{parentName:"li"},"codegen-units = 1"),"."))),(0,r.kt)("li",{parentName:"ul"},"When you need a map, use ",(0,r.kt)("inlineCode",{parentName:"li"},"BTreeMap")," instead of ",(0,r.kt)("inlineCode",{parentName:"li"},"HashMap"),"."),(0,r.kt)("li",{parentName:"ul"},"When you need to hash data, use the ",(0,r.kt)("a",{parentName:"li",href:"https://dev.risczero.com/zkvm/developer-guide/acceleration"},"accelerated implementation of SHA-256"),"."),(0,r.kt)("li",{parentName:"ul"},"Look for places where you are copying or (de)serializing data when not necessary.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"appendix"},"Appendix"),(0,r.kt)("h3",{id:"rv32im-operations-with-cycle-counts"},"RV32IM Operations with Cycle Counts"),(0,r.kt)("p",null,"Table from ",(0,r.kt)("a",{parentName:"p",href:"https://mark.theis.site/riscv/"},"https://mark.theis.site/riscv/"),", with RISC Zero cycle counts added."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Assembly"),(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Pseudocode"),(0,r.kt)("th",{parentName:"tr",align:null},"RISC Zero Cycles"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LUI rd,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Load Upper Immediate"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 imm"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AUIPC rd,offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Add Upper Immediate to PC"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 pc + offset"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"JAL rd,offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Jump and Link"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 pc + length(inst)pc \u2190 pc + offset"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"JALR rd,rs1,offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Jump and Link Register"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 pc + length(inst)pc \u2190 (rs1 + offset) \u2227 -2"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BEQ rs1,rs2,offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Branch Equal"),(0,r.kt)("td",{parentName:"tr",align:null},"if rs1 = rs2 then pc \u2190 pc + offset"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BNE rs1,rs2,offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Branch Not Equal"),(0,r.kt)("td",{parentName:"tr",align:null},"if rs1 \u2260 rs2 then pc \u2190 pc + offset"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BLT rs1,rs2,offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Branch Less Than"),(0,r.kt)("td",{parentName:"tr",align:null},"if rs1 < rs2 then pc \u2190 pc + offset"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BGE rs1,rs2,offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Branch Greater than Equal"),(0,r.kt)("td",{parentName:"tr",align:null},"if rs1 \u2265 rs2 then pc \u2190 pc + offset"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BLTU rs1,rs2,offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Branch Less Than Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"if rs1 < rs2 then pc \u2190 pc + offset"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BGEU rs1,rs2,offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Branch Greater than Equal Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"if rs1 \u2265 rs2 then pc \u2190 pc + offset"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LB rd,offset(rs1)"),(0,r.kt)("td",{parentName:"tr",align:null},"Load Byte"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 s8","[rs1 + offset]"),(0,r.kt)("td",{parentName:"tr",align:null},"1 if ",(0,r.kt)("a",{parentName:"td",href:"#paging"},"paged-in")," 1094 to 5130 otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LH rd,offset(rs1)"),(0,r.kt)("td",{parentName:"tr",align:null},"Load Half"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 s16","[rs1 + offset]"),(0,r.kt)("td",{parentName:"tr",align:null},"1 if ",(0,r.kt)("a",{parentName:"td",href:"#paging"},"paged-in")," 1094 to 5130 otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LW rd,offset(rs1)"),(0,r.kt)("td",{parentName:"tr",align:null},"Load Word"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 s32","[rs1 + offset]"),(0,r.kt)("td",{parentName:"tr",align:null},"1 if ",(0,r.kt)("a",{parentName:"td",href:"#paging"},"paged-in")," 1094 to 5130 otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LBU rd,offset(rs1)"),(0,r.kt)("td",{parentName:"tr",align:null},"Load Byte Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 u8","[rs1 + offset]"),(0,r.kt)("td",{parentName:"tr",align:null},"1 if ",(0,r.kt)("a",{parentName:"td",href:"#paging"},"paged-in")," 1094 to 5130 otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LHU rd,offset(rs1)"),(0,r.kt)("td",{parentName:"tr",align:null},"Load Half Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 u16","[rs1 + offset]"),(0,r.kt)("td",{parentName:"tr",align:null},"1 if ",(0,r.kt)("a",{parentName:"td",href:"#paging"},"paged-in")," 1094 to 5130 otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SB rs2,offset(rs1)"),(0,r.kt)("td",{parentName:"tr",align:null},"Store Byte"),(0,r.kt)("td",{parentName:"tr",align:null},"u8","[rs1 + offset]"," \u2190 rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"1 if ",(0,r.kt)("a",{parentName:"td",href:"#paging"},"paged-in")," 1094 to 5130 otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SH rs2,offset(rs1)"),(0,r.kt)("td",{parentName:"tr",align:null},"Store Half"),(0,r.kt)("td",{parentName:"tr",align:null},"u16","[rs1 + offset]"," \u2190 rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"1 if ",(0,r.kt)("a",{parentName:"td",href:"#paging"},"paged-in")," 1094 to 5130 otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SW rs2,offset(rs1)"),(0,r.kt)("td",{parentName:"tr",align:null},"Store Word"),(0,r.kt)("td",{parentName:"tr",align:null},"u32","[rs1 + offset]"," \u2190 rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"1 if ",(0,r.kt)("a",{parentName:"td",href:"#paging"},"paged-in")," 1094 to 5130 otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ADDI rd,rs1,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Add Immediate"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 rs1 + sx(imm)"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SLTI rd,rs1,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Set Less Than Immediate"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 sx(rs1) < sx(imm)"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SLTIU rd,rs1,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Set Less Than Immediate Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) < ux(imm)"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"XORI rd,rs1,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Xor Immediate"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \u2295 ux(imm)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ORI rd,rs1,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Or Immediate"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \u2228 ux(imm)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ANDI rd,rs1,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"And Immediate"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \u2227 ux(imm)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SLLI rd,rs1,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Shift Left Logical Immediate"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \xab ux(imm)"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SRLI rd,rs1,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Shift Right Logical Immediate"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \xbb ux(imm)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SRAI rd,rs1,imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Shift Right Arithmetic Immediate"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 sx(rs1) \xbb ux(imm)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ADD rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Add"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 sx(rs1) + sx(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SUB rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Subtract"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 sx(rs1) - sx(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SLL rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Shift Left Logical"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \xab rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SLT rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Set Less Than"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 sx(rs1) < sx(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SLTU rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Set Less Than Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) < ux(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"XOR rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Xor"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \u2295 ux(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SRL rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Shift Right Logical"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \xbb rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SRA rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Shift Right Arithmetic"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 sx(rs1) \xbb rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"OR rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Or"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \u2228 ux(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AND rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"And"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \u2227 ux(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MUL rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Multiply"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \xd7 ux(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MULH rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Multiply High Signed Signed"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 (sx(rs1) \xd7 sx(rs2)) \xbb xlen"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MULHSU rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Multiply High Signed Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 (sx(rs1) \xd7 ux(rs2)) \xbb xlen"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MULHU rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Multiply High Unsigned Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 (ux(rs1) \xd7 ux(rs2)) \xbb xlen"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DIV rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Divide Signed"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 sx(rs1) \xf7 sx(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DIVU rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Divide Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) \xf7 ux(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"REM rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Remainder Signed"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 sx(rs1) mod sx(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"REMU rd,rs1,rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Remainder Unsigned"),(0,r.kt)("td",{parentName:"tr",align:null},"rd \u2190 ux(rs1) mod ux(rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"2")))),(0,r.kt)("h3",{id:"risc-zero-ecall-operations"},"RISC Zero ECALL Operations"),(0,r.kt)("p",null,"RISC-V specifies a mechanism for environment calls (ecalls), which may be specified by the vendor.\nIn RISC Zero\u2019s zkVM, ecalls are specified for a number of core operations.\nA short description and associated cycle counts are listed below."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Selector"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Operations"),(0,r.kt)("th",{parentName:"tr",align:null},"Cycles"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HALT"),(0,r.kt)("td",{parentName:"tr",align:null},"Halt execution"),(0,r.kt)("td",{parentName:"tr",align:null},"Set system exit code to a0. Load 32-bytes output digest from ","[a1]",". Set output digest global. Halt execution."),(0,r.kt)("td",{parentName:"tr",align:null},"1 + paging")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SOFTWARE"),(0,r.kt)("td",{parentName:"tr",align:null},"Receive data from the host"),(0,r.kt)("td",{parentName:"tr",align:null},"Write host-provided data to the memory range ","[a0 .. a0 + a1 * 4]"),(0,r.kt)("td",{parentName:"tr",align:null},"1 + \u2308 a1 / 4 \u2309 + paging")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SHA-256"),(0,r.kt)("td",{parentName:"tr",align:null},"SHA-256 hash"),(0,r.kt)("td",{parentName:"tr",align:null},"Compute the Merkle\u2013Damg\xe5rd compression of the region ","[a2 .. a2 + a3 * 64]"," with initial state ","[a1]",". Write the digest to ","[a0]","."),(0,r.kt)("td",{parentName:"tr",align:null},"6 + 68 ","*"," a2 + paging")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BIGINT"),(0,r.kt)("td",{parentName:"tr",align:null},"256-bit modular operation"),(0,r.kt)("td",{parentName:"tr",align:null},"if a1 = 0, ","[a0]"," \u2190 ","[a2]"," \u22c5 ","[a3]"," (mod ","[a4]",")"),(0,r.kt)("td",{parentName:"tr",align:null},"10 + paging")))),(0,r.kt)("hr",null),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},(0,r.kt)("p",{parentName:"li"},"Modern processors have endlessly complex systems of pipelining, instruction-level parallelism, micro-ops and other details that bend the concept of \u201ccycle\u201d and make it impossible to say definitive how many \u201ccycles\u201d an operation takes.\nIt is still an good intuitive starting point and working model.",(0,r.kt)("a",{parentName:"p",href:"#fnref-1",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-2"},(0,r.kt)("p",{parentName:"li"},"Here \u201csampling\u201d is in quotes because the profiler actually captures the call stack at every cycle of program execution. Capturing a call stack on every cycle of execution is not done in most programs on physical CPUs for a few reasons:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"It would be cost prohibitive to do so for all but quite short program executions."),(0,r.kt)("li",{parentName:"ul"},"Introducing such heavy profiling would actually alter the performance characteristics in significant ways.")),(0,r.kt)("p",{parentName:"li"},"In zkVM execution, executions are generally short and all execution is synchronous and is not subject to any deviations in behavior due to measurement overhead.",(0,r.kt)("a",{parentName:"p",href:"#fnref-2",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-3"},(0,r.kt)("p",{parentName:"li"},"An implementation of cycle-accounting for paging operations is implemented in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/risc0/risc0/blob/v0.19.0/risc0/zkvm/src/host/server/exec/monitor.rs#L30-L39"},"Executor"),". (Link is to v0.19.0)",(0,r.kt)("a",{parentName:"p",href:"#fnref-3",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-4"},(0,r.kt)("p",{parentName:"li"},"This is similar to the cryptography support such as ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/AES_instruction_set#x86_architecture_processors"},"AES-NI")," or the ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Intel_SHA_extensions"},"SHA extensions")," for x86 processors.\nIn both cases, the circuitry is extended to compute otherwise expensive operations in fewer instruction cycles.",(0,r.kt)("a",{parentName:"p",href:"#fnref-4",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-5"},(0,r.kt)("p",{parentName:"li"},"RISC Zero has an implementation for Apple\u2019s Metal accelerators.\nUnfortunately, it is does not work with the latest versions of Metal as of October 2023. See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/risc0/risc0/issues/937"},"https://github.com/risc0/risc0/issues/937"),(0,r.kt)("a",{parentName:"p",href:"#fnref-5",className:"footnote-backref"},"\u21a9"))))))}u.isMDXComponent=!0},2613:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ecdsa-verification-flamegraph-1bbb98199aeeccb65f92679600a3e3e6.png"}}]);