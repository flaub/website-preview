"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7406],{6743:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var s=i(5893),r=i(1151);const t={},a="Guest Optimization Guide",o={id:"zkvm/optimization",title:"Guest Optimization Guide",description:"RISC Zero\u2019s zkVM is designed and built to act like a physical CPU. We did this",source:"@site/api_versioned_docs/version-0.20/zkvm/optimization.md",sourceDirName:"zkvm",slug:"/zkvm/optimization",permalink:"/website-preview/risc0/risc0/pr/1428/api/zkvm/optimization",draft:!1,unlisted:!1,editUrl:"https://github.com/risc0/risc0/edit/main/website/api/zkvm/optimization.md",tags:[],version:"0.20",frontMatter:{},sidebar:"api",previous:{title:"Receipts 101",permalink:"/website-preview/risc0/risc0/pr/1428/api/zkvm/receipts"},next:{title:"Cryptography Acceleration",permalink:"/website-preview/risc0/risc0/pr/1428/api/zkvm/acceleration"}},d={},c=[{value:"Background",id:"background",level:2},{value:"What is the zkVM, really?",id:"what-is-the-zkvm-really",level:3},{value:"What is a \u201ccycle\u201d?",id:"what-is-a-cycle",level:3},{value:"General techniques and advice",id:"general-techniques-and-advice",level:2},{value:"Don\u2019t assume, measure.",id:"dont-assume-measure",level:3},{value:"Measuring by printing to console",id:"measuring-by-printing-to-console",level:3},{value:"Profiling",id:"profiling",level:3},{value:"Key Differences",id:"key-differences",level:2},{value:"Most RISC-V operations take exactly one cycle",id:"most-risc-v-operations-take-exactly-one-cycle",level:3},{value:"Memory access costs one cycle, except when it doesn\u2019t",id:"memory-access-costs-one-cycle-except-when-it-doesnt",level:3},{value:"Paging",id:"paging",level:4},{value:"The zkVM does not have native floating point operations",id:"the-zkvm-does-not-have-native-floating-point-operations",level:3},{value:"Unaligned data access is significantly more expensive",id:"unaligned-data-access-is-significantly-more-expensive",level:3},{value:"When reading data as raw bytes, use <code>env::read_slice</code>",id:"when-reading-data-as-raw-bytes-use-envread_slice",level:3},{value:"When you only need part of the input data, try Merklizing it",id:"when-you-only-need-part-of-the-input-data-try-merklizing-it",level:3},{value:"Cryptography in the guest can utilize accelerator circuits",id:"cryptography-in-the-guest-can-utilize-accelerator-circuits",level:3},{value:"Memory access is synchronous",id:"memory-access-is-synchronous",level:3},{value:"All execution is single-threaded",id:"all-execution-is-single-threaded",level:3},{value:"The zkVM has no pipelining or other instruction-level parallelism.",id:"the-zkvm-has-no-pipelining-or-other-instruction-level-parallelism",level:3},{value:"Prover Acceleration",id:"prover-acceleration",level:2},{value:"TL;DR and quick wins",id:"tldr-and-quick-wins",level:2},{value:"Appendix",id:"appendix",level:2},{value:"RV32IM Operations with Cycle Counts",id:"rv32im-operations-with-cycle-counts",level:3},{value:"RISC Zero ECALL Operations",id:"risc-zero-ecall-operations",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"guest-optimization-guide",children:"Guest Optimization Guide"}),"\n",(0,s.jsxs)(n.p,{children:["RISC Zero\u2019s zkVM is designed and built to act like a physical CPU. We did this\nso you could use general purpose languages (e.g. Rust) and general purpose tools\n(e.g. Cargo, LLVM). ",(0,s.jsx)(n.strong,{children:"Generally, you can apply general purpose optimization\ntechniques too!"})]}),"\n",(0,s.jsxs)(n.p,{children:["In this guide, we\u2019ll cover optimization of ",(0,s.jsx)(n.a,{href:"/website-preview/risc0/risc0/pr/1428/api/zkvm/guest-code-101",children:"zkVM guest programs"}),". We\u2019ll discuss\nwhen you can apply common techniques from other contexts, and when you need a\nnew approach."]}),"\n",(0,s.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-the-zkvm-really",children:"What is the zkVM, really?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The zkVM is essentially a CPU."})}),"\n",(0,s.jsxs)(n.p,{children:["In particular, it is an implementation of the ",(0,s.jsx)(n.a,{href:"/reference-docs/about-risc-v",children:"RISC-V architecture"}),"\n(specifically riscv32im), similar to how your laptop\u2019s CPU may be an\nimplementation of an ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/X86",children:"x86"})," or ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/ARM_architecture_family",children:"ARM"})," architecture. This biggest difference is\nthat the zkVM is implemented with ",(0,s.jsx)(n.a,{href:"/reference-docs/about-arithmetic-circuits",children:"arithmetic circuits"}),", in software, instead of\ncircuitry made from silicon and copper."]}),"\n",(0,s.jsx)(n.h3,{id:"what-is-a-cycle",children:"What is a \u201ccycle\u201d?"}),"\n",(0,s.jsx)(n.p,{children:"Both in the zkVM and on physical CPUs, the cost of an operation is measured in\n\u201cclock cycles\u201d."}),"\n",(0,s.jsx)(n.p,{children:"Intuitively, a \"clock cycle\" is the smallest unit of time in a CPU's operation,\nrepresenting one tick of the CPU's internal clock and the time it takes to\nexecute a basic CPU operation (e.g. adding two integers). We\u2019ll refer to this as\na \u201ccycle\u201d."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Proving times for the zkVM are directly related to the number of cycles in an\nexecution."})}),"\n",(0,s.jsx)(n.h2,{id:"general-techniques-and-advice",children:"General techniques and advice"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Start by applying general techniques and best practices for optimizing your\ncode."})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://nnethercote.github.io/perf-book/",children:"The Rust Performance Book"})," is great resource. It\u2019s not very long, it\ncovers a range of topics important to performance, and gives applicable advice\nfor optimization. If you are new to optimization, or new to Rust, we recommend\nyou read this guide."]}),"\n",(0,s.jsx)(n.h3,{id:"dont-assume-measure",children:"Don\u2019t assume, measure."}),"\n",(0,s.jsx)(n.p,{children:"Performance is complex, in the zkVM as on a physical CPU.\nDon\u2019t assume you know what the bottlenecks are. Measure and experiment."}),"\n",(0,s.jsxs)(n.p,{children:["If you make a function 100x faster (or \u221ex faster) but it only takes 1% of your\nexecution time, you\u2019ll see less than 1% improvement in performance. This is\ngenerally referred to as ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Amdahl%27s_law",children:"Amdahl\u2019s Law"}),", and practically it means you\nshouldn't waste your time optimizing something that's not the taking a\nsignificant portion of execution time."]}),"\n",(0,s.jsx)(n.h3,{id:"measuring-by-printing-to-console",children:"Measuring by printing to console"}),"\n",(0,s.jsxs)(n.p,{children:["Starting simple, measure by adding an ",(0,s.jsx)(n.code,{children:"eprintln!"})," line to your guest code to\nmeasure how long an operation takes, and how many times it is called."]}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.a,{href:"https://docs.rs/risc0-zkvm/0.20/risc0_zkvm/guest/env/fn.cycle_count.html",children:(0,s.jsx)(n.code,{children:"env::cycle_count()"})})," will tell you the current number of execution\ncycles that have occurred in your program."]}),"\n",(0,s.jsx)(n.p,{children:"As an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'no_run title="methods/guest/src/main.rs"',children:'fn my_operation_to_measure() {\n  let start = env::cycle_count();\n\n  // potentially expensive or frequently called code\n  // ...\n\n  let end = env::cycle_count();\n  eprintln!("my_operation_to_measure: {}", end - start);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When you run your guest, you\u2019ll see a printout of the cycle count each time that\nfunction is called. You can then analyze this data easily with a tool like\n",(0,s.jsx)(n.a,{href:"https://github.com/nnethercote/counts/",children:(0,s.jsx)(n.code,{children:"counts"})}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"profiling",children:"Profiling"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Profiling is one of the most important tools for understanding and optimizing\nyour code."})}),"\n",(0,s.jsxs)(n.p,{children:["Profiling tools, like ",(0,s.jsx)(n.a,{href:"https://github.com/google/pprof",children:"pprof"})," and ",(0,s.jsx)(n.a,{href:"https://perf.wiki.kernel.org/index.php/Main_Page",children:"perf"}),", allow collecting performance\ninformation over the entire execution of your program, and help create\nvisualizations for the performance of your program. RISC Zero has experimental\nsupport for generating pprof files for cycle counts."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://nikhilism.com/post/2018/sampling-profiler-internals-introduction/",children:"Sampling CPU profilers"}),', as implemented by pprof and perf, provide a view of\nwhere your program is spending its time. It does so by recording the current\ncall stack at a sampling interval. RISC Zero provides a "sampling" ',(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," CPU\nprofiler for guest execution."]}),"\n",(0,s.jsxs)(n.p,{children:["One very useful visualization of this data is as a ",(0,s.jsx)(n.a,{href:"https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html",children:"flamegraph"}),", such as the one\nbelow for the ",(0,s.jsx)(n.a,{href:"https://github.com/risc0/risc0/tree/release-0.20/examples/ecdsa",children:"ECDSA verification example"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"/img/ecdsa-verification-flamegraph.png",alt:"ECDSA verification flamegraph"})}),"\n",(0,s.jsxs)(n.p,{children:["Generate this profile and flamegraph by ",(0,s.jsx)(n.a,{href:"https://go.dev/doc/install",children:"installing Go"})," and\nrunning the following commands:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# In your clone of github.com/risc0/risc0\ncd examples/ecdsa\nRISC0_PPROF_OUT=ecdsa_verify.pb RISC0_DEV_MODE=true cargo run\ngo tool pprof -http 127.0.0.1:8000 ecdsa_verify.pb\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Open ",(0,s.jsx)(n.a,{href:"http://127.0.0.1:8000/ui/flamegraph",children:"http://127.0.0.1:8000/ui/flamegraph"}),"\nin your web browser to see the flamegraph."]}),"\n",(0,s.jsxs)(n.p,{children:["Although it\u2019s bundled with Go, the ",(0,s.jsx)(n.code,{children:"pprof"})," tool can be used with profiles from\nprograms not written in Golang. ",(0,s.jsx)(n.code,{children:"pprof"})," has extensive functionality, and the\ndocumentation linked below contains information about the different views\nprovided, comparing profiles, and much more."]}),"\n",(0,s.jsxs)(n.p,{children:["Documentation for ",(0,s.jsx)(n.code,{children:"pprof"}),": ",(0,s.jsx)(n.a,{href:"https://github.com/google/pprof",children:"github.com/google/pprof"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["More information about profiling can be found in the ",(0,s.jsx)(n.a,{href:"/website-preview/risc0/risc0/pr/1428/api/zkvm/profiling",children:"Guest Profiling\nGuide"})]})}),"\n",(0,s.jsx)(n.h2,{id:"key-differences",children:"Key Differences"}),"\n",(0,s.jsx)(n.p,{children:"Using general purpose advice and tools for optimization will work 80% of the\ntime. But there are some key differences between how physical CPUs and the zkVM\noperate that can be important to understand when trying to get the best possible\nguest performance."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"This section explains some of the most important differences between a\nphysical CPU and the zkVM, as they relate to guest performance."})}),"\n",(0,s.jsxs)(n.h3,{id:"most-risc-v-operations-take-exactly-one-cycle",children:["Most ",(0,s.jsx)(n.a,{href:"https://mark.theis.site/riscv/",children:"RISC-V operations"})," take exactly one cycle"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Not all operations cost the same amount."})," An ",(0,s.jsx)(n.code,{children:"add"})," instruction takes fewer\ncycles than a ",(0,s.jsx)(n.code,{children:"div"}),". This is true for both the zkVM and physical CPUs."]}),"\n",(0,s.jsxs)(n.p,{children:["However, the relative difference between instructions is much smaller in the\nzkVM. In the zkVM, a ",(0,s.jsx)(n.code,{children:"div"})," takes twice as long as an ",(0,s.jsx)(n.code,{children:"add"}),". On a physical CPU, a\n",(0,s.jsx)(n.code,{children:"div"})," takes ",(0,s.jsx)(n.a,{href:"http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/",children:"15-40 times"})," as long compared to an ",(0,s.jsx)(n.code,{children:"add"}),". Practically,\nthis means if you have a choice between implementing an ",(0,s.jsx)(n.a,{href:"https://briansmith.org/ecc-inversion-addition-chains-01",children:"algorithm"})," with 10\n",(0,s.jsx)(n.code,{children:"add"})," ops, or a single ",(0,s.jsx)(n.code,{children:"div"}),". On a physical CPU, choose the ",(0,s.jsx)(n.code,{children:"add"})," ops. In the\nzkVM choose the ",(0,s.jsx)(n.code,{children:"div"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Addition, comparison, jump, shift left, load and store all take one cycle."}),"\n",(0,s.jsx)(n.li,{children:"Bitwise operations (AND, OR, XOR), division, remainder, and shift right take\ntwo cycles."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Note that this means that shift left is no faster than multiplying by a power of\ntwo, and shift right is no faster than division. A number of other small\noptimizations like this, routinely applied by developers and compilers, have no\neffect in the zkVM."}),"\n",(0,s.jsxs)(n.p,{children:["See the ",(0,s.jsx)(n.a,{href:"#rv32im-operations-with-cycle-counts",children:"table in the appendix"})," for more information about cycle\ncounts per operation."]}),"\n",(0,s.jsx)(n.h3,{id:"memory-access-costs-one-cycle-except-when-it-doesnt",children:"Memory access costs one cycle, except when it doesn\u2019t"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://mark.theis.site/riscv/",children:"RISC-V operations"})," require data to be loaded from memory to ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Processor_register",children:"registers"})," before\nit can acted on (e.g. used as input to an ",(0,s.jsx)(n.code,{children:"add"}),"). It must also be written back\nto memory to store the result. Memory loads and stores (i.e. reads and writes)\nusually take one cycle."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory access, both load and store takes exactly one cycle, expect in the case\nof page-in and page-out operations (",(0,s.jsx)(n.a,{href:"#paging",children:"discussed below"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that relative to a physical CPU, this is extremely fast (in terms of\ncycles). On a physical CPU even a value in ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cache_hierarchy",children:"L1 cache"})," takes ",(0,s.jsx)(n.a,{href:"http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/",children:"3-4\ncycles"})," to access. L3 cache takes ",(0,s.jsx)(n.a,{href:"http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/",children:"30-70 cycles"})," and main\nmemory ",(0,s.jsx)(n.a,{href:"http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/",children:"100-150"}),". One of the most common bottlenecks in applications\nis the round-trip time it takes to access a data in memory."]}),"\n",(0,s.jsx)(n.h4,{id:"paging",children:"Paging"}),"\n",(0,s.jsxs)(n.p,{children:["Every execution of the zkVM starts from an initial memory state. This memory\nstate (a.k.a. image) is referenced by an ",(0,s.jsx)(n.a,{href:"/terminology#image-id",children:"image ID"}),", which contains a ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Merkle_tree",children:"Merkle\nroot"})," committing to all data in memory. For efficiency, data in memory is split\ninto 1 kB pages."]}),"\n",(0,s.jsxs)(n.p,{children:["Pages in the zkVM are analogous a ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Page_(computer_memory)",children:"page in an operating system"}),", and in\nparticular this term was chosen in reference to ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Memory_paging",children:"memory paging"}),", or swapping,\nsystems. Execution of a program is split into ",(0,s.jsx)(n.a,{href:"https://www.risczero.com/news/continuations",children:"continuation segments"}),". Between\nsegments, the zkVM essentially ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Hibernation_(computing)",children:"hibernates"}),", saving all working memory to the\nhost; as a CPU would use a hard drive."]}),"\n",(0,s.jsxs)(n.p,{children:["The first time a page is accessed in a segment, it needs to be ",(0,s.jsx)(n.strong,{children:"paged-in"}),",\nloading it from the host. Confirming the page is correct, the guest verifies a\nMerkle inclusion proof for the page against the image ID. These hashing\noperations required take a number of cycles."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"A page-in operation takes between 1094 and 5130 cycles; 1130 cycles on\naverage."}),(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})})]}),"\n",(0,s.jsx)(n.p,{children:"The very first page-in takes longer, 5130 cycles, because it needs to traverse\nup the page table (i.e. Merkle tree) all the way to the root, which is equal to\nthe image ID. Once a path is verified, it doesn\u2019t need to be hashed again, so\nmost page-in operations only need to hash the leaf (i.e. data) page. If a\nprogram were to iterate over memory in sequence, it would cost on average 1130\ncycles per page, or 1.35 cycles per byte."}),"\n",(0,s.jsxs)(n.p,{children:["In order to support continuation after the segment ends (i.e. the zkVM\n\u201chibernates\u201d), it needs to ",(0,s.jsx)(n.strong,{children:"page-out"})," pages that were modified. Paging-out\ntakes the same number of operations as paging-in, so for the first time any\ngiven page is written to in a segment, there is an page-out cost of 1094 to 5130\ncycles."]}),"\n",(0,s.jsx)(n.p,{children:"If, after profiling your application, you learn page-in and page-out operations\nare a significant overhead, you can optimize your application by reducing it\u2019s\nmemory usage and locality. This will be somewhat similar to optimizing for data\nlocality and L1/2 cache usage. Using fewer pages, using the same page repeatedly\ninstead of a random access pattern, and condensing the range of addresses\naccessed can all help reduce paging overhead. It\u2019s best to experiment."}),"\n",(0,s.jsx)(n.h3,{id:"the-zkvm-does-not-have-native-floating-point-operations",children:"The zkVM does not have native floating point operations"}),"\n",(0,s.jsx)(n.p,{children:"The RISC Zero zkVM does not implement the RISC-V floating point instructions. As\na result, all floating point operations are emulated in software. In contrast to\ninteger operations that take 1-2 cycles, floating point operations can take\n60-140 cycles for basic operations such as add, subtract, multiply, and divide."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When possible, use integers instead of floating point numbers."})}),"\n",(0,s.jsx)(n.h3,{id:"unaligned-data-access-is-significantly-more-expensive",children:"Unaligned data access is significantly more expensive"}),"\n",(0,s.jsx)(n.p,{children:"CPUs define a standard size of data for operation; and this is referred to as a\nword. In RISC-V 32-bit ISA, the size of a word is 32 bits (4 bytes). Memory is\nalways read and stored as words."}),"\n",(0,s.jsxs)(n.p,{children:["When the read or store address is not a multiple of 4 bytes, the operation is\nmuch more expensive. In a simple benchmark, reading an unaligned ",(0,s.jsx)(n.code,{children:"u32"})," value\ncosts 12 cycles, versus 1 cycle for an aligned read."]}),"\n",(0,s.jsx)(n.p,{children:"All allocations will be aligned by default, and the compiler wants to help you,\nso this should usually not be an issue."}),"\n",(0,s.jsxs)(n.p,{children:["If you are defining structs that containing small primitive typed fields (e.g.\n",(0,s.jsx)(n.code,{children:"bool"}),", ",(0,s.jsx)(n.code,{children:"u8"}),", ",(0,s.jsx)(n.code,{children:"i16"}),") and access this data very frequently, you might consider\npaying extra care to the ",(0,s.jsx)(n.a,{href:"https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers",children:"alignment of those fields"}),". Additionally,\nif you are slicing into byte arrays, try to do so at word-aligned indices."]}),"\n",(0,s.jsxs)(n.h3,{id:"when-reading-data-as-raw-bytes-use-envread_slice",children:["When reading data as raw bytes, use ",(0,s.jsx)(n.code,{children:"env::read_slice"})]}),"\n",(0,s.jsxs)(n.p,{children:["When reading input into the guest, ",(0,s.jsx)(n.a,{href:"https://docs.rs/risc0-zkvm/0.20/risc0_zkvm/guest/env/fn.read.html",children:(0,s.jsx)(n.code,{children:"env::read"})})," is the main API to use. It\nautomatically deserializes the input bytes into structs, like in this ",(0,s.jsx)(n.a,{href:"https://github.com/risc0/risc0/blob/release-0.20/examples/password-checker/methods/guest/src/main.rs#L24",children:"snippet\nfrom the password checker example"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"let request: PasswordRequest = env::read();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the host code, ",(0,s.jsx)(n.code,{children:"ExecutorEnvBuilder::write"})," function is used to serialize and\nwrite to input struct so that the guest can read it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let request = PasswordRequest { /* .. */ };\nlet env = ExecutorEnv::builder()\n        .write(&request).unwrap()\n        .build()\n        .unwrap();\n"})}),"\n",(0,s.jsx)(n.p,{children:"In most cases, these APIs are what you should use to send data to the guest."}),"\n",(0,s.jsxs)(n.p,{children:["However, when you need to read and work with data as raw bytes (or words), it is\nmore efficient to use ",(0,s.jsx)(n.a,{href:"https://docs.rs/risc0-zkvm/0.20//0.20/risc0_zkvm/guest/env/fn.read_slice.html",children:(0,s.jsx)(n.code,{children:"env::read_slice"})})," or ",(0,s.jsx)(n.code,{children:"env::stdin().read_to_end"}),". Both\nmethods do no (de)serialization and so do not need to copy or reinterpret the\ninput data. Examples of when this may be useful are if you are reading in image\ndata as bytes, or reading data that is binary encoded from the source like with\n",(0,s.jsx)(n.a,{href:"https://cbor.io/",children:"CBOR"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Here is a ",(0,s.jsx)(n.a,{href:"https://github.com/risc0/risc0/blob/release-0.20/bonsai/examples/governance/methods/guest/src/bin/finalize_votes.rs#L88-L90",children:"snippet from the Bonsai Governance\nexample"})," showing how to read bytes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"let mut input_bytes = Vec::<u8>::new();\nenv::stdin().read_to_end(&mut input_bytes).unwrap();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["On the host side, ",(0,s.jsx)(n.code,{children:"ExecutorEnvBuilder::write_slice"})," is used to pass in the bytes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let input_bytes: Vec<u8> = b"INPUT DATA".to_vec();\nlet env = ExecutorEnv::builder()\n        .write_slice(&input_bytes)\n        .build()\n        .unwrap();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"when-you-only-need-part-of-the-input-data-try-merklizing-it",children:"When you only need part of the input data, try Merklizing it"}),"\n",(0,s.jsxs)(n.p,{children:["Some programs only need part of the whole available data. ",(0,s.jsx)(n.a,{href:"https://github.com/risc0/risc0/tree/release-0.20/examples/waldo",children:"Where\u2019s\nWaldo"})," is an example of this. The full input is an image, but\nonly the part with Waldo in it is needed. Loading and hashing the whole image\nwould be quite expensive, so instead the initial input for the guest is just the\nMerkle root and each chunk is loaded dynamically. The guest verifies that the\nchunk is indeed part of the image by verifying the Merkle inclusion proof."]}),"\n",(0,s.jsxs)(n.p,{children:["If you are writing a guest with a large input, and only part of it is needed for\nthe computation, consider splitting it into some notion of a chunks and building\nit as a Merkle tree. You can use the ",(0,s.jsx)(n.a,{href:"https://github.com/risc0/risc0/blob/release-0.20/examples/waldo/core/src/merkle.rs",children:"code for Where\u2019s Waldo"})," as a\nstarting point."]}),"\n",(0,s.jsx)(n.h3,{id:"cryptography-in-the-guest-can-utilize-accelerator-circuits",children:"Cryptography in the guest can utilize accelerator circuits"}),"\n",(0,s.jsxs)(n.p,{children:["RISC Zero\u2019s riscv32im implementation includes a number of special purpose\noperations, including two \u201caccelerators\u201d for cryptographic functions: SHA-256\nand ",(0,s.jsx)(n.a,{href:"https://github.com/risc0/risc0/pull/466",children:"256-bit modular multiplication"}),". By implementing these operations\ndirectly in the \u201chardware\u201d of the zkVM, programs that use these accelerators\nexecute faster and can be proven with significantly less resources ",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-3",id:"user-content-fnref-3","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For more information about cryptography acceleration, ",(0,s.jsx)(n.a,{href:"/website-preview/risc0/risc0/pr/1428/api/zkvm/acceleration",children:"cryptography\nacceleration"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Using the accelerator, a SHA-256 compress operation typically takes 68 cycles\nper 64-byte block and 6 cycles to initialize. A 256-bit modular multiply takes\n10 cycles. This includes basic memory operation cycles, but does not include\npage-in or page-out operations that are triggered."}),"\n",(0,s.jsx)(n.h3,{id:"memory-access-is-synchronous",children:"Memory access is synchronous"}),"\n",(0,s.jsxs)(n.p,{children:["On a physical CPU, memory access is asynchronous to register operations; meaning\narithmetic or logic operations on registers can run while the CPU is waiting for\nthe result from memory. Because the memory fetch latency is quite large\n(100-150x the time to ",(0,s.jsx)(n.code,{children:"add"})," two registers), this gives rise to techniques such\nas prefetching and speculative execution, implemented both at the processor and\napplication levels."]}),"\n",(0,s.jsxs)(n.p,{children:["In the zkVM, all memory operations are synchronous, regardless of if the data is\ncurrently paged-in. ",(0,s.jsx)(n.strong,{children:"Memory prefetching does not help (but can hurt) zkVM guest\nperformance."})]}),"\n",(0,s.jsx)(n.h3,{id:"all-execution-is-single-threaded",children:"All execution is single-threaded"}),"\n",(0,s.jsxs)(n.p,{children:["The zkVM has one core and one thread of execution. As a result, there is no need\nor use for multi-threading. ",(0,s.jsxs)(n.strong,{children:["Using ",(0,s.jsx)(n.code,{children:"async"})," routines, locking, or atomic\noperations in the guest can only slow the program down."]})]}),"\n",(0,s.jsx)(n.h3,{id:"the-zkvm-has-no-pipelining-or-other-instruction-level-parallelism",children:"The zkVM has no pipelining or other instruction-level parallelism."}),"\n",(0,s.jsxs)(n.p,{children:["Modern processors have execution pipelines and ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Superscalar_processor",children:"superscalar\narchitectures"})," designed to ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Instruction-level_parallelism",children:"execute instructions in parallel"}),".\nInstruction throughput is much higher when the pipeline is kept full and\nindependent execution units are utilized. CPUs implement out-of-order and\nspeculative execution, among other techniques to achieve this."]}),"\n",(0,s.jsx)(n.p,{children:"By comparison, RISC Zero\u2019s riscv32im implementation is very simple. Instructions\nwill be read from the guest program and executed in the order chosen by the\ncompiler."}),"\n",(0,s.jsxs)(n.p,{children:["Developers and compilers often use techniques such as pre-fetching, avoiding\nbranches, or reordering instructions to maximize instruction-level parallelism.\n",(0,s.jsx)(n.strong,{children:"These techniques have essentially no effect in the zkVM."})]}),"\n",(0,s.jsx)(n.h2,{id:"prover-acceleration",children:"Prover Acceleration"}),"\n",(0,s.jsx)(n.p,{children:"You are probably interested in guest optimization in order to have faster\nproving times, to reduce compute costs, or both. RISC Zero can leverage hardware\naccelerators, the ones made of real silicon this time, to accomplish both of\nthese objectives."}),"\n",(0,s.jsxs)(n.p,{children:["With an NVIDIA graphics card, proving can be accelerated through the ",(0,s.jsx)(n.a,{href:"https://developer.nvidia.com/cuda-toolkit",children:"CUDA"}),"\nimplementation. When running a zkVM application, a compatible version of the\nCUDA runtime needs to be installed. When building the zkVM from source, a\ncompatible version of the CUDA toolkit needs to be installed on the build\nmachine, and the ",(0,s.jsx)(n.code,{children:"cuda"})," feature enabled."]}),"\n",(0,s.jsx)(n.h2,{id:"tldr-and-quick-wins",children:"TL;DR and quick wins"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/website-preview/risc0/risc0/pr/1428/api/zkvm/profiling",children:"Profile your applications"})," to find where cycles are being spent."]}),"\n",(0,s.jsxs)(n.li,{children:["Try different ",(0,s.jsx)(n.a,{href:"https://doc.rust-lang.org/cargo/reference/profiles.html",children:"compiler settings"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Setting ",(0,s.jsx)(n.code,{children:'lto = "thin"'})," is sometimes faster than ",(0,s.jsx)(n.code,{children:'lto = "fat"'})," or ",(0,s.jsx)(n.code,{children:"lto = true"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Sometimes ",(0,s.jsx)(n.code,{children:"opt-level = 2"})," is faster than ",(0,s.jsx)(n.code,{children:"3"}),". Try ",(0,s.jsx)(n.code,{children:"s"})," and ",(0,s.jsx)(n.code,{children:"z"})," too."]}),"\n",(0,s.jsxs)(n.li,{children:["Try setting ",(0,s.jsx)(n.code,{children:"codegen-units = 1"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["When you need a map, use ",(0,s.jsx)(n.code,{children:"BTreeMap"})," instead of ",(0,s.jsx)(n.code,{children:"HashMap"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["When you need to hash data, use the ",(0,s.jsx)(n.a,{href:"/website-preview/risc0/risc0/pr/1428/api/zkvm/acceleration",children:"accelerated implementation of\nSHA-256"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Look for places where you are copying or (de)serializing data when not\nnecessary."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"appendix",children:"Appendix"}),"\n",(0,s.jsx)(n.h3,{id:"rv32im-operations-with-cycle-counts",children:"RV32IM Operations with Cycle Counts"}),"\n",(0,s.jsxs)(n.p,{children:["Table from ",(0,s.jsx)(n.a,{href:"https://mark.theis.site/riscv/",children:"https://mark.theis.site/riscv/"}),", with RISC Zero\ncycle counts added."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Assembly"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Pseudocode"}),(0,s.jsx)(n.th,{children:"RISC Zero Cycles"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LUI rd,imm"}),(0,s.jsx)(n.td,{children:"Load Upper Immediate"}),(0,s.jsx)(n.td,{children:"rd \u2190 imm"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"AUIPC rd,offset"}),(0,s.jsx)(n.td,{children:"Add Upper Immediate to PC"}),(0,s.jsx)(n.td,{children:"rd \u2190 pc + offset"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JAL rd,offset"}),(0,s.jsx)(n.td,{children:"Jump and Link"}),(0,s.jsx)(n.td,{children:"rd \u2190 pc + length(inst)pc \u2190 pc + offset"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JALR rd,rs1,offset"}),(0,s.jsx)(n.td,{children:"Jump and Link Register"}),(0,s.jsx)(n.td,{children:"rd \u2190 pc + length(inst)pc \u2190 (rs1 + offset) \u2227 -2"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"BEQ rs1,rs2,offset"}),(0,s.jsx)(n.td,{children:"Branch Equal"}),(0,s.jsx)(n.td,{children:"if rs1 = rs2 then pc \u2190 pc + offset"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"BNE rs1,rs2,offset"}),(0,s.jsx)(n.td,{children:"Branch Not Equal"}),(0,s.jsx)(n.td,{children:"if rs1 \u2260 rs2 then pc \u2190 pc + offset"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"BLT rs1,rs2,offset"}),(0,s.jsx)(n.td,{children:"Branch Less Than"}),(0,s.jsx)(n.td,{children:"if rs1 < rs2 then pc \u2190 pc + offset"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"BGE rs1,rs2,offset"}),(0,s.jsx)(n.td,{children:"Branch Greater than Equal"}),(0,s.jsx)(n.td,{children:"if rs1 \u2265 rs2 then pc \u2190 pc + offset"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"BLTU rs1,rs2,offset"}),(0,s.jsx)(n.td,{children:"Branch Less Than Unsigned"}),(0,s.jsx)(n.td,{children:"if rs1 < rs2 then pc \u2190 pc + offset"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"BGEU rs1,rs2,offset"}),(0,s.jsx)(n.td,{children:"Branch Greater than Equal Unsigned"}),(0,s.jsx)(n.td,{children:"if rs1 \u2265 rs2 then pc \u2190 pc + offset"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LB rd,offset(rs1)"}),(0,s.jsx)(n.td,{children:"Load Byte"}),(0,s.jsx)(n.td,{children:"rd \u2190 s8[rs1 + offset]"}),(0,s.jsxs)(n.td,{children:["1 if ",(0,s.jsx)(n.a,{href:"#paging",children:"paged-in"})," 1094 to 5130 otherwise"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LH rd,offset(rs1)"}),(0,s.jsx)(n.td,{children:"Load Half"}),(0,s.jsx)(n.td,{children:"rd \u2190 s16[rs1 + offset]"}),(0,s.jsxs)(n.td,{children:["1 if ",(0,s.jsx)(n.a,{href:"#paging",children:"paged-in"})," 1094 to 5130 otherwise"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LW rd,offset(rs1)"}),(0,s.jsx)(n.td,{children:"Load Word"}),(0,s.jsx)(n.td,{children:"rd \u2190 s32[rs1 + offset]"}),(0,s.jsxs)(n.td,{children:["1 if ",(0,s.jsx)(n.a,{href:"#paging",children:"paged-in"})," 1094 to 5130 otherwise"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LBU rd,offset(rs1)"}),(0,s.jsx)(n.td,{children:"Load Byte Unsigned"}),(0,s.jsx)(n.td,{children:"rd \u2190 u8[rs1 + offset]"}),(0,s.jsxs)(n.td,{children:["1 if ",(0,s.jsx)(n.a,{href:"#paging",children:"paged-in"})," 1094 to 5130 otherwise"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LHU rd,offset(rs1)"}),(0,s.jsx)(n.td,{children:"Load Half Unsigned"}),(0,s.jsx)(n.td,{children:"rd \u2190 u16[rs1 + offset]"}),(0,s.jsxs)(n.td,{children:["1 if ",(0,s.jsx)(n.a,{href:"#paging",children:"paged-in"})," 1094 to 5130 otherwise"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SB rs2,offset(rs1)"}),(0,s.jsx)(n.td,{children:"Store Byte"}),(0,s.jsx)(n.td,{children:"u8[rs1 + offset] \u2190 rs2"}),(0,s.jsxs)(n.td,{children:["1 if ",(0,s.jsx)(n.a,{href:"#paging",children:"paged-in"})," 1094 to 5130 otherwise"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SH rs2,offset(rs1)"}),(0,s.jsx)(n.td,{children:"Store Half"}),(0,s.jsx)(n.td,{children:"u16[rs1 + offset] \u2190 rs2"}),(0,s.jsxs)(n.td,{children:["1 if ",(0,s.jsx)(n.a,{href:"#paging",children:"paged-in"})," 1094 to 5130 otherwise"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SW rs2,offset(rs1)"}),(0,s.jsx)(n.td,{children:"Store Word"}),(0,s.jsx)(n.td,{children:"u32[rs1 + offset] \u2190 rs2"}),(0,s.jsxs)(n.td,{children:["1 if ",(0,s.jsx)(n.a,{href:"#paging",children:"paged-in"})," 1094 to 5130 otherwise"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ADDI rd,rs1,imm"}),(0,s.jsx)(n.td,{children:"Add Immediate"}),(0,s.jsx)(n.td,{children:"rd \u2190 rs1 + sx(imm)"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SLTI rd,rs1,imm"}),(0,s.jsx)(n.td,{children:"Set Less Than Immediate"}),(0,s.jsx)(n.td,{children:"rd \u2190 sx(rs1) < sx(imm)"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SLTIU rd,rs1,imm"}),(0,s.jsx)(n.td,{children:"Set Less Than Immediate Unsigned"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) < ux(imm)"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"XORI rd,rs1,imm"}),(0,s.jsx)(n.td,{children:"Xor Immediate"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \u2295 ux(imm)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ORI rd,rs1,imm"}),(0,s.jsx)(n.td,{children:"Or Immediate"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \u2228 ux(imm)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ANDI rd,rs1,imm"}),(0,s.jsx)(n.td,{children:"And Immediate"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \u2227 ux(imm)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SLLI rd,rs1,imm"}),(0,s.jsx)(n.td,{children:"Shift Left Logical Immediate"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \xab ux(imm)"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SRLI rd,rs1,imm"}),(0,s.jsx)(n.td,{children:"Shift Right Logical Immediate"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \xbb ux(imm)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SRAI rd,rs1,imm"}),(0,s.jsx)(n.td,{children:"Shift Right Arithmetic Immediate"}),(0,s.jsx)(n.td,{children:"rd \u2190 sx(rs1) \xbb ux(imm)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ADD rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Add"}),(0,s.jsx)(n.td,{children:"rd \u2190 sx(rs1) + sx(rs2)"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SUB rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Subtract"}),(0,s.jsx)(n.td,{children:"rd \u2190 sx(rs1) - sx(rs2)"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SLL rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Shift Left Logical"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \xab rs2"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SLT rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Set Less Than"}),(0,s.jsx)(n.td,{children:"rd \u2190 sx(rs1) < sx(rs2)"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SLTU rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Set Less Than Unsigned"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) < ux(rs2)"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"XOR rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Xor"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \u2295 ux(rs2)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SRL rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Shift Right Logical"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \xbb rs2"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SRA rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Shift Right Arithmetic"}),(0,s.jsx)(n.td,{children:"rd \u2190 sx(rs1) \xbb rs2"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"OR rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Or"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \u2228 ux(rs2)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"AND rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"And"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \u2227 ux(rs2)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"MUL rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Multiply"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \xd7 ux(rs2)"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"MULH rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Multiply High Signed Signed"}),(0,s.jsx)(n.td,{children:"rd \u2190 (sx(rs1) \xd7 sx(rs2)) \xbb xlen"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"MULHSU rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Multiply High Signed Unsigned"}),(0,s.jsx)(n.td,{children:"rd \u2190 (sx(rs1) \xd7 ux(rs2)) \xbb xlen"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"MULHU rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Multiply High Unsigned Unsigned"}),(0,s.jsx)(n.td,{children:"rd \u2190 (ux(rs1) \xd7 ux(rs2)) \xbb xlen"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"DIV rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Divide Signed"}),(0,s.jsx)(n.td,{children:"rd \u2190 sx(rs1) \xf7 sx(rs2)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"DIVU rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Divide Unsigned"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) \xf7 ux(rs2)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REM rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Remainder Signed"}),(0,s.jsx)(n.td,{children:"rd \u2190 sx(rs1) mod sx(rs2)"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REMU rd,rs1,rs2"}),(0,s.jsx)(n.td,{children:"Remainder Unsigned"}),(0,s.jsx)(n.td,{children:"rd \u2190 ux(rs1) mod ux(rs2)"}),(0,s.jsx)(n.td,{children:"2"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"risc-zero-ecall-operations",children:"RISC Zero ECALL Operations"}),"\n",(0,s.jsx)(n.p,{children:"RISC-V specifies a mechanism for environment calls (ecalls), which may be\nspecified by the vendor. In RISC Zero\u2019s zkVM, ecalls are specified for a number\nof core operations. A short description and associated cycle counts are listed\nbelow."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Selector"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Operations"}),(0,s.jsx)(n.th,{children:"Cycles"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"HALT"}),(0,s.jsx)(n.td,{children:"Halt execution"}),(0,s.jsx)(n.td,{children:"Set system exit code to a0. Load 32-bytes output digest from [a1]. Set output digest global. Halt execution."}),(0,s.jsx)(n.td,{children:"1 + paging"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SOFTWARE"}),(0,s.jsx)(n.td,{children:"Receive data from the host"}),(0,s.jsx)(n.td,{children:"Write host-provided data to the memory range [a0 .. a0 + a1 * 4]"}),(0,s.jsx)(n.td,{children:"1 + \u2308 a1 / 4 \u2309 + paging"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SHA-256"}),(0,s.jsx)(n.td,{children:"SHA-256 hash"}),(0,s.jsx)(n.td,{children:"Compute the Merkle\u2013Damg\xe5rd compression of the region [a2 .. a2 + a3 * 64] with initial state [a1]. Write the digest to [a0]."}),(0,s.jsx)(n.td,{children:"6 + 68 * a2 + paging"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"BIGINT"}),(0,s.jsx)(n.td,{children:"256-bit modular operation"}),(0,s.jsx)(n.td,{children:"if a1 = 0, [a0] \u2190 [a2] \u22c5 [a3] (mod [a4])"}),(0,s.jsx)(n.td,{children:"10 + paging"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,s.jsx)(n.p,{children:"Here \u201csampling\u201d is in quotes because the profiler actually captures the call\nstack at every cycle of program execution. Capturing a call stack on every\ncycle of execution is not done in most programs on physical CPUs for a few\nreasons:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It would be cost prohibitive to do so for all but quite short program\nexecutions."}),"\n",(0,s.jsx)(n.li,{children:"Introducing such heavy profiling would actually alter the performance\ncharacteristics in significant ways."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In zkVM execution, executions are generally short and all execution is\nsynchronous and is not subject to any deviations in behavior due to\nmeasurement overhead. ",(0,s.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,s.jsxs)(n.p,{children:["An implementation of cycle-accounting for paging operations is implemented\nin the ",(0,s.jsx)(n.a,{href:"https://github.com/risc0/risc0/blob/release-0.20/risc0/zkvm/src/host/server/exec/monitor.rs#L30-L39",children:"Executor"}),". ",(0,s.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-3",children:["\n",(0,s.jsxs)(n.p,{children:["This is similar to the cryptography support such as ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/AES_instruction_set#x86_architecture_processors",children:"AES-NI"})," or the ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Intel_SHA_extensions",children:"SHA\nextensions"})," for x86 processors. In both cases, the circuitry is extended to\ncompute otherwise expensive operations in fewer instruction cycles. ",(0,s.jsx)(n.a,{href:"#user-content-fnref-3","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>a});var s=i(7294);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);